# Task 1 #

## Steps 1 and 2 ##
* Forked the github repo to my own github account
* Cloned the repo to my device using github desktop
* Opened the folder in VS Code 

## Step 3 ##
In this step, the counter module was instantiated in a new System Verilog file:
<img width="800" alt="image" src="https://user-images.githubusercontent.com/69715492/197180860-12b9a7fe-0549-4364-9853-43c6339eb11e.png">

When reset is high the 'if' condition is met and the counter value is set to 1'b0 with a bit length of the WIDTH parameter (stated as 8 bits when the counter was instantiated). 

Else, the counter = previous counter + 8 bit incrementor. The 8 bit number is is formed by carrying out bitwise manipulation and concatenation: {WIDTH-1{1'b0}, en}. The WIDTH - 1 means the most significant 7 bits is set to 0. The LSB = enable value. When enable value is high (1) the counter increments, otherwise (0) the counter is unchanged.

The counter's functionality (combination of multiplexer and D-type flip-flop):
<img width="943" alt="image" src="https://user-images.githubusercontent.com/69715492/197209833-10319aa3-0721-4f01-a037-1fdd17b019ca.png">

## Step 4 ##
In this step, the test bench file was created.

<img width="700" alt="image" src="https://user-images.githubusercontent.com/69715492/197181477-ed2eccc6-3f83-4300-aa79-7ba6cc9f115d.png">

The code above is a template for all other testbench files. It consists of various sections which have been explained.
1. Header files
2. Initiating i (index for loop) and clk variable (which links to system verilog counter file)
3. Instantiate system verilog counter module in C++ code. This is the DUT
4. For dumping waveform data to counter.vcd to then be viewed using GTKWave
5. Set value of initial signal levels
6. For loop for running the clock cycles
7. Toggles clock
8. Changes rst and en signals
## Step 5 ##
In this step, I opened the terminal and ran three commands to run the script and generate the waveforms.

* Running verilator command translated counter.sv (counter module code) into C++ code and merged with testbench C++ code. Ths produces a number of file in obj_dir folder including a .mk file called Vcounter.mk.

```
#run Verilator to translate Verilog into C++, including C++ testbench
verilator -Wall --cc --trace counter.sv --exe counter_tb.cpp
```
* Running make command builds executable model of counter

```
# build C++ project via make automatically generated by Verilator
make -j -C obj_dir/ -f Vcounter.mk Vcounter
```
* Finally I ran the executable simulation file which generated the counter.vcd file which displays the waveform (when opened using GTK Wave)
```
# run executable simulation file
obj_dir/Vcounter
```

## Step 6 ##
Opened counter.vcd file in gtkwave to get a waveform:

<img width="600" alt="image" src="https://user-images.githubusercontent.com/69715492/196927519-165f4c2b-0dbf-49d1-abe0-d73e3fa92f44.png">

**How do the waveform signals work?**

**A NOTE ON THE eval() FUNCTION:**\
Looking at the section of the testbench code which dumps info into the .vcd file (which GTK then runs to display the waveforms):
<img width="786" alt="image" src="https://user-images.githubusercontent.com/69715492/197191642-935e261b-8c61-489a-92b8-472e925533cc.png">

We can see that the eval() function comes after the clk line. This means all the evaluations occur "during the clock cycle" but that does not show up until the positive edge of the next clock cycle in the waveform on GTK. So if rst is to be 0 when i == 2. This means at positive edge of clock cycle 2, rst is still 1. During this clock cycle the eval function occurs and rst changes. However this change is displayed at the positive edge of clock cycle 3. 

NOTE: Changes made during a clock cycle don't show up in the waveform till the next clock cycle (due to the position of the eval function in the testbench code).

**CLK**: goes up and down at fixed term intervals

**RST/EN**:\
In the testbench file counter_tb.cpp\
<img width="226" alt="image" src="https://user-images.githubusercontent.com/69715492/196928951-51261de5-75c1-4212-a76e-6b9f1492ca39.png">

It states the conditions for rst and en to activate
<img width="1103" alt="image" src="https://user-images.githubusercontent.com/69715492/197187879-88332e2f-48ec-458d-bba2-700e60f715ee.png">

Looking at rst: we know rst should be 1 while clock cycle < 2. This means rst is set to 0 during clock cycle 2. This is what happens, however we don't see the change in the waveform till the positive edge of clock cycle 3 due to the nature of the code.

**Count**:\
To understand the count waveform we need to look at the counter module code in the System Verilog file (counter.sv)
<img width="456" alt="image" src="https://user-images.githubusercontent.com/69715492/196931531-76219837-3eaa-4cf0-ae43-b8664503e4c9.png">

Line 12 tells us if rst is asserted, the counter is synchronously reset to 0. Else the count is increased by 1 (given that the enable is also high). All of this occurs at the postive edge of the clock (showed by *posedge clk*)

<img width="1062" alt="image" src="https://user-images.githubusercontent.com/69715492/197195653-ccc6f135-7523-4bd6-a0cd-0b95f5492975.png">

The reset is triggered during clock cycle 15 (i==15). This is displayed at the positive edge of cycle 16. The counter then experiences the reset during clock cycle 16, and this is displayed at the positive edge of clock cycle 17.


## TEST YOURSELF CHALLENGES ##
**1. Modify testbench so that you stop counting for 3 cycles once the counter reaches 0x9, and then resume counting** 
<img width="515" alt="image" src="https://user-images.githubusercontent.com/69715492/196978376-0ee430e4-8386-4bd5-bd15-c92dbdaa7793.png">
* Got rid of the reset at clock cycle 15
* Set enable to 0 from clock 15 to clock 17
<img width="800" alt="image" src="https://user-images.githubusercontent.com/69715492/196979455-c386eea2-5f03-439c-801a-f5489770b115.png">

***Incorrect Approach***

<img width="228" alt="image" src="https://user-images.githubusercontent.com/69715492/196974695-26e149a6-1dc1-412e-8559-5e5299d512e8.png">

Removed (i==15) from top->rst condition (which was correct) but changed top->en condition to (4<i & i<15 | i>17)

This produced the following waveform

<img width="767" alt="image" src="https://user-images.githubusercontent.com/69715492/197200545-4dcd5d5b-da80-4dce-b889-0e8260defb1c.png">

Enable set to 0 during clock cycle 15 (displayed in waveform at p.e. of cycle  meaning the counter stops counting at clock cycle 16). Hence the counter already reaches 0A and then stops, instead of stopping at 09. Decreasing to i<=13 (i<14) fixed this issue. 

Furthermore, the counter stops for 4 cycles instead of 3. This is because the enable gets set to high during i=18 (i>17), and then counter restarts at the clock cycle after that (note the changes occur in the positive edge at the clock cycle afterwards due to the eval() position as mentioned before). Decreasing the range to i>=16 (i>15) fixed this issue.


**2. Implement asynchronous reset**

Adding posedge rst within the always_ff @() makes reset asynchronous

<img width="350" alt="image" src="https://user-images.githubusercontent.com/69715492/196984778-835abecd-34f6-4e94-9317-ec0076a86ff6.png">

I set the reset to i==8.

<img width="350" alt="image" src="https://user-images.githubusercontent.com/69715492/196984885-9dc991c0-a869-4301-bbc9-d3a8e6226ab0.png">

Giving a waveform where the reset does not occur at the positive edge of the clock cycle

<img width="786" alt="image" src="https://user-images.githubusercontent.com/69715492/196985652-07029d04-823f-4cc1-ab56-39189ed97dfa.png">




